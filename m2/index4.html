<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>test</title>
    <link href="css/style.css" rel="stylesheet"></link>
    <script src="js/script.js"></script>
<style>
#text-area {
    width: 100%;
    height: 100%;
    margin: 10px
}
#sample {
    font-family: "MS Gothic", "ＭＳ ゴシック", monospace;
    border: 1px solid black;
    padding: 20px;
    white-space: pre-line;
}
#cursor {
    position: absolute;
    width: 1px;
    background: black;
    display: none;
    animation: blink 1s steps(1) infinite;
}
@keyframes blink {
    50% { opacity: 0; }
}
span.unconfirmed {
    text-decoration: underline;
    color: gray;
}
span.selected {
    cursor: pointer;
}
span.selected-mock{
    color: rgb(255, 255, 255);
    background-color: rgb(0, 120, 215);
}
span.moved {
    color: red;
}
span.pad {
    color: rgba(255, 0, 0, 0.05);
}
</style>
</head>
<body style="margin:0">

<div id="text-area">
    <div id="sample" draggable>窓の外に広がる街並みは、朝の光に静かに照らされていた。カフェの角を曲がると、すれ違う人々の足音が心地よいリズムを刻む。誰もがそれぞれの目的を胸に抱き、歩みを進めている。その中で、私はただ立ち止まり、時間の流れをそっと感じていた。風に運ばれる珈琲の香りと、遠くで笑う子供たちの声が、今日の始まりを告げている。</div>
    <!-- <div id="sample" draggable>あいうえお</div> -->
    <div id="cursor"></div>
    <input id="hiddenInput" style="position:absolute; opacity:0.5;">
</div>

<script>
const text = document.getElementById("sample");
const cursor = document.getElementById("cursor");
const hiddenInput = document.getElementById("hiddenInput");
let content = text.textContent;

let caretBeforeIdx = -1;
let caretAfterIdx = -1;
let caretBeforeChars = [];
let caretAfterChars = [];
let composingChars = [];

let allCharRects = [];

let isComposing = false;
let isComposingEnd = false;

let selectedStartOffset = -1;
let selectedEndOffset = -1;
let selectionCount = {
    left : 0,
    right: 0
}

let beforeSelectionChars = [];
let selectionSpan = null;
let afterSelectionChars = [];
let charInfosForSelection = [];

let isSelected = false;
let isInputInSelection = false;
let isSelectionWithKeyboard = false;
let isLastCursor = false;

let mouseDownPos = {
    x: -1,
    y: -1
}
let mouseUpPos = {
    x: -1,
    y: -1
}

let selectionPos = -1;

let isBackSpace = false;
let isDelete = false;

function hasSpan(){
    for(const node of text.childNodes){
        if(node.nodeType === Node.ELEMENT_NODE && node.tagName === "SPAN") return true;
    }
    return false;
}

function collectInsertedChar(){
    return Array.from(text.children).map(x => x.textContent).join("");
}

function updateContent(){
    content = collectInsertedChar();
}

function initUnselectionChars(){
    beforeSelectionChars.length = 0;
    afterSelectionChars.length = 0;
}

function initComposingChars(){
    composingChars.length = 0;
}

function initInput(){
    hiddenInput.value = "";
}

function normalizeText(){
    updateContent();
    initUnselectionChars();
    text.innerHTML = content;
}

function removeSelection(){
    const selection = window.getSelection();
    selection.removeAllRanges();
    const range = document.createRange();
    range.setStart(document.body, 0);
    range.setEnd(document.body, 0);
    selection.addRange(range);
}

function clearSelection(){
    removeSelection();
    selectionCount.left = 0;
    selectionCount.right = 0;
    isSelectionWithKeyboard = false;
    isSelected = false;
    text.querySelectorAll("span").forEach(span => {
        if(!span.classList.contains("selected")) return;
        span.classList.remove("selected");
        span.classList.remove("selected-mock");
    });
}

function selectStr(startNode, start = -1, endNode = null, end = -1){
    const selection = window.getSelection();
    selection.removeAllRanges();
    const range = document.createRange();

    if(start == -1 && end == -1){
        range.selectNodeContents(startNode);
        selection.addRange(range);
    }else{

    }
}

function setSelectionOffset(){
    const selection = window.getSelection();
    const range = selection.getRangeAt(0);
    const preRange = document.createRange();
    preRange.selectNodeContents(text);
    preRange.setEnd(range.startContainer, range.startOffset);

    selectedStartOffset = preRange.toString().length;
    selectedEndOffset = selectedStartOffset + range.toString().length;
}

text.addEventListener("mousedown", e => {
    mouseDownPos.x = e.clientX;
    mouseDownPos.y = e.clientY;
});

text.addEventListener("dragstart", e => {
    if(!isSelected) return;
    selectionSpan.classList.add("moved");
    removeSelection();
});

text.addEventListener("drag", e => {
    if(!isSelected) return;

    const repointedX = e.clientX + window.scrollX;
    const repointedY = e.clientY + window.scrollY;

    for(let i = 0; i < charInfosForSelection.length; i++){
        if(charInfosForSelection[i].left <= repointedX && charInfosForSelection[i].right >= repointedX
            && charInfosForSelection[i].top <= repointedY && charInfosForSelection[i].bottom >= repointedY){
            renderForEstimate(i);
            return;
        }
    }
});

text.addEventListener("dragend", e => {
    const spans = text.querySelectorAll("span");
    const segments = {
        before   : "",
        selection: "",
        after    : ""
    }
    
    let isSelection = false;
    for(let i = 0; i < spans.length; i++){
        if(spans[i].className === "pad") continue;
        if(spans[i].className === "moved"){
            isSelection = true;
            segments.selection += spans[i].textContent;
            continue;
        }
        if(isSelection) segments.after += spans[i].textContent;
        else segments.before += spans[i].textContent;
    }

    content = "";
    const flag = document.createDocumentFragment();

    if(segments.before !== ""){
        const beforeSelection = createSpan(segments.before);
        flag.appendChild(beforeSelection);
        content += segments.before;
    }
    const selection = createSpan(segments.selection, "selected selected-mock");
    flag.appendChild(selection);
    content += selection.textContent;
    if(segments.after !== ""){
        const afterSelection = createSpan(segments.after);
        flag.appendChild(afterSelection);
        content += afterSelection.textContent;
    }

    text.innerHTML = "";
    text.appendChild(flag);

    selectStr(selection);
    setSelectionOffset();

    beforeSelectionChars = content.slice(0, selectedStartOffset).split("");
    selectionSpan = selection;
    afterSelectionChars = content.slice(selectedEndOffset).split("");
    
    renderForSelection();

    isSelected = true;
    isRightToLeft = true;
});

text.addEventListener("mouseup", e =>{
    const selection = window.getSelection();
    const selectedText = selection.toString();

    if(selectedText.length === 0) {
        clearSelection();
        return;
    }

    mouseUpPos.x = e.clientX;
    mouseUpPos.y = e.clientY;
    if(mouseDownPos.x === mouseUpPos.x && mouseDownPos.y === mouseUpPos.y) {
        clearSelection();
        return;
    }

    setSelectionOffset();

    isSelected = true;
    isRightToLeft = true;
});

function hideTextCursor(){
    cursor.style.display = "none";
}

text.addEventListener("click", e =>{
    if(hasSpan()) normalizeText();
    if (!isSelected) {
        const pos = document.caretPositionFromPoint(e.clientX, e.clientY);

        caretBeforeChars = content.slice(0, pos.offset).split("");
        caretAfterChars = content.slice(pos.offset).split("");

        clearSelection();
        hiddenInput.focus();
        render();
    }else{
        beforeSelectionChars = content.slice(0, selectedStartOffset).split("");
        selectionSpan = createSpan(content.slice(selectedStartOffset, selectedEndOffset), "selected selected-mock");
        afterSelectionChars = content.slice(selectedEndOffset).split("");

        renderForSelection();

        selectStr(selectionSpan);
    }
});

hiddenInput.addEventListener("input", e => {
    console.log("ss");
    const char = e.data;
    if(isSelected) isInputInSelection = true;
    if(!isComposing){
        caretBeforeChars.push(char);
        e.target.value = "";
    }
    render();
});

hiddenInput.addEventListener("compositionupdate", e => {
    isComposing = true;
    composingChars = e.data.split("");
    if(!composingChars.length){
        isComposingEnd = true;
        initComposingChars();
    }
});

hiddenInput.addEventListener("compositionend", e => {
    isComposingEnd = true;
    isComposing = false;
    caretBeforeChars = caretBeforeChars.concat(e.data.split(""));
    initComposingChars();
    initInput();
    render();
});

function selectInputText(input, start = 0, end = null) {
    input.focus(); // フォーカスを当てる
    if (end === null) end = input.value.length;
    input.setSelectionRange(start, end);
}

function mouseenterSelectedMock(e){
    initInput();
    selectStr(selectionSpan);
}

function mouseleaveSelectedMock(e){
    hiddenInput.value = selectionSpan.textContent;
    selectInputText(hiddenInput);
}

// キー操作
hiddenInput.addEventListener("keydown", e => {
    window.kcode = e.code;
    if (e.code === "Backspace") {
        isBackSpace = true;
        if(isSelected){
            caretBeforeChars = beforeSelectionChars;
            caretAfterChars = afterSelectionChars;
        }
        if(!isComposing) render();
        isSelected = false;
        selectionCount.left = 0;
        selectionCount.right = 0;
        hiddenInput.focus();
        e.preventDefault();
    } else if (e.key === "Delete") {
        isDelete = true;
        if(isSelected){
            caretBeforeChars = beforeSelectionChars;
            caretAfterChars = afterSelectionChars;
        }
        render();
        isSelected = false;
        selectionCount.left = 0;
        selectionCount.right = 0;
        hiddenInput.focus();
        e.preventDefault();
    } else if (e.code === "Enter") {
        if(!isComposing){
            caretBeforeChars.push('\n');
            render();
            e.preventDefault();
        }
    } else if (e.code === "ArrowLeft") {
        if(isComposing) return;

        if(e.shiftKey){
            if(!caretBeforeChars.length) return;

            if(isSelectionWithKeyboard){
                beforeSelectionChars = caretBeforeChars.slice(0, selectionCount.right ? -selectionCount.right : -1);
                afterSelectionChars = selectionCount.right
                    ? caretBeforeChars.slice(-1).concat(caretAfterChars)
                    : caretAfterChars.slice(selectionCount.left);
                const selectionChars = selectionCount.right
                    ? caretBeforeChars.slice(-selectionCount.right, -1)
                    : caretBeforeChars.slice(-1).concat(caretAfterChars.slice(0, selectionCount.left));
                selectionSpan = createSpan(selectionChars.join(""), "selected selected-mock");
            }else{
                beforeSelectionChars = caretBeforeChars.slice(0, -1);
                afterSelectionChars = caretAfterChars;
                selectionSpan = createSpan(caretBeforeChars.slice(-1).join(""), "selected selected-mock");

                isSelectionWithKeyboard = true;
            }

            if(selectionCount.right > 0) selectionCount.right -= 1;
            else selectionCount.left += 1;

            if(selectionCount.left === 0 && selectionCount.right === 0) isSelectionWithKeyboard = false;

            renderForSelection();

            isSelected = true;

            e.preventDefault();
            return;
        }
        
        if(isSelected) clearSelection();
        if(!caretBeforeChars.length) return;
        if(isLastCursor){
            positionCursor(text.querySelector("span:last-child"));
        }else{
            caretAfterChars.unshift(caretBeforeChars.pop());
            render();
        }
        e.preventDefault();
    } else if (e.code === "ArrowRight") {
        if(isComposing)return;

        if(e.shiftKey){
            if(isLastCursor) return;

            if(isSelectionWithKeyboard){
                beforeSelectionChars = selectionCount.left
                    ? caretBeforeChars.concat(caretAfterChars.slice(0, 1))
                    : caretBeforeChars.slice(0, -selectionCount.right);
                afterSelectionChars = caretAfterChars.slice(selectionCount.left ? selectionCount.left : 1);
                const selectionChars = selectionCount.left
                    ? caretAfterChars.slice(1, selectionCount.left)
                    : caretBeforeChars.slice(-selectionCount.right).concat(caretAfterChars.slice(0, 1));
                selectionSpan = createSpan(selectionChars.join(""), "selected selected-mock");
            }else{
                beforeSelectionChars = caretBeforeChars;
                afterSelectionChars = caretAfterChars.slice(1);
                selectionSpan = createSpan(caretAfterChars.slice(0, 1).join(""), "selected selected-mock");

                isSelectionWithKeyboard = true;
            }

            if(selectionCount.left > 0) selectionCount.left -= 1;
            else selectionCount.right += 1;

            if(selectionCount.left === 0 && selectionCount.right === 0) isSelectionWithKeyboard = false;

            renderForSelection();

            isSelected = true;

            e.preventDefault();
            console.log(caretBeforeChars.join(""))
            console.log(caretAfterChars.join(""))
            return;
        }

        if(isSelected) clearSelection();
        if(caretAfterChars.length === 1){
            positionCursor(text.querySelector("span:last-child"), "after");
        }else{
            caretBeforeChars.push(caretAfterChars.shift());
            render();
        }
        e.preventDefault();
    } else if (e.code === "ArrowUp") {
        if(isComposing) return;
        if(isSelected) clearSelection();

        const baseChar = caretAfterChars.length
            ? allCharRects[caretBeforeChars.length]
            : allCharRects[caretBeforeChars.length - 1];
        
        upLineChars = allCharRects.filter(x => x.bottom < baseChar.bottom);
        if(!upLineChars.length) return;

        const upLineBottom = upLineChars[upLineChars.length - 1].bottom;
        let candidateChar = upLineChars
            .filter(x => x.bottom === upLineBottom)
            .reduce( (acc, cur) => {
                const diffCurrent = Math.abs(baseChar.left - acc.left);
                const diffNew = Math.abs(baseChar.left - cur.left);
                return diffNew < diffCurrent ? cur : acc;
            }, upLineChars[0]);
            
        const moveCharCount = caretBeforeChars.length - candidateChar.index;
        const moved = caretBeforeChars.splice(-moveCharCount);
        caretAfterChars.unshift(...moved);

        render();
        e.preventDefault();
    } else if (e.code === "ArrowDown") {
        if(isComposing) return;
        if(isSelected) clearSelection();

        const baseChar = caretAfterChars.length
            ? allCharRects[caretBeforeChars.length]
            : allCharRects[caretBeforeChars.length - 1];
        
        downLineChars = allCharRects.filter(x => x.bottom > baseChar.bottom);
        if(!downLineChars.length) return;

        const downLineBottom = downLineChars[0].bottom;
        let candidateChar = downLineChars
            .filter(x => x.bottom === downLineBottom)
            .reduce( (acc, cur) => {
                const diffCurrent = Math.abs(baseChar.left - acc.left);
                const diffNew = Math.abs(baseChar.left - cur.left);
                return diffNew < diffCurrent ? cur : acc;
            }, downLineChars[0]);
            
        const moveCharCount = candidateChar.index - caretBeforeChars.length;
        const moved = caretAfterChars.splice(0, moveCharCount);
        caretBeforeChars.push(...moved);

        render();
        e.preventDefault();
    } else {
    }
});

function renderForEstimate(idx) {
    const estimateTexts = [];

    if(charInfosForSelection[idx].pos === "s"){
        estimateTexts.push({
            style: "normal",
            text : charInfosForSelection.filter(x => x.pos === "b").map(x => x.char).join("")
        });

        estimateTexts.push({
            style: "moved",
            text : charInfosForSelection[idx].char
        });

        estimateTexts.push({
            style: "normal",
            text : charInfosForSelection.filter(x => x.pos === "a").map(x => x.char).join("")
        })
    }else{
        if(idx < selectionPos){
            estimateTexts.push({
                style: "normal",
                text : charInfosForSelection.slice(0, idx).map(x => x.char).join("")
            });
            estimateTexts.push({
                style: "moved",
                text : selectionSpan.textContent
            });
            estimateTexts.push({
                style: "normal",
                text : charInfosForSelection.slice(idx, selectionPos).map(x => x.char).join("")
            });
            estimateTexts.push({
                style: "pad",
                text : selectionSpan.textContent
            });
            estimateTexts.push({
                style: "normal",
                text : charInfosForSelection.filter(x => x.pos === "a").map(x => x.char).join("")
            });
        }else{
            estimateTexts.push({
                style: "normal",
                text : charInfosForSelection.filter(x => x.pos === "b").map(x => x.char).join("")
            });
            estimateTexts.push({
                style: "pad",
                text : selectionSpan.textContent
            });
            estimateTexts.push({
                style: "normal",
                text : charInfosForSelection.slice(selectionPos + 1, idx + 1).map(x => x.char).join("")
            });
            estimateTexts.push({
                style: "moved",
                text : selectionSpan.textContent
            });
            estimateTexts.push({
                style: "normal",
                text : charInfosForSelection.slice(idx + 1).map(x => x.char).join("")
            });
        }
    }

    const spans = text.querySelectorAll("span");
    for(let i = 0; i < spans.length; i++){
        if(estimateTexts[i] === undefined) {
            spans[i].textContent = "";
            continue;
        }
        spans[i].textContent = estimateTexts[i].text;
        spans[i].className = estimateTexts[i].style;
    }
}

function createCharInfos(span, pos, idx, str = null){
    const rect = span.getBoundingClientRect();
    return {
        char  : str == null ? span.textContent : str,
        pos   : pos,
        idx   : idx,
        left  : window.scrollX + rect.left,
        top   : window.scrollY + rect.top,
        right : window.scrollX + rect.right,
        bottom: window.scrollY + rect.bottom
    }
}

function renderForSelection() {
    text.innerHTML = "";
    charInfosForSelection.length = 0

    // 選択文字列より前の文字列
    for(let i = 0; i < beforeSelectionChars.length; i++){
        const char = beforeSelectionChars[i]
        const span = createSpan(char);
        text.appendChild(span);
        charInfosForSelection.push(createCharInfos(span, "b", i));
    }

    // 選択文字列
    selectionPos = beforeSelectionChars.length;
    const selectionStr = selectionSpan.textContent;
    const tempSpan1 = createSpan(selectionStr.slice(0, -1));
    text.appendChild(tempSpan1);
    const tempSpan2 = createSpan(selectionStr.slice(-1));
    text.appendChild(tempSpan2);
    const lastSelectionChar = tempSpan2.getBoundingClientRect();
    text.removeChild(text.lastElementChild);
    text.removeChild(text.lastElementChild);
    if(selectionStr.length !== 1){
        const tempSpan = createSpan(selectionStr.slice(0, 1));
        text.appendChild(tempSpan);
        charInfosForSelection.push(createCharInfos(tempSpan, "s", selectionPos, selectionStr));
        text.removeChild(text.lastElementChild);
        text.appendChild(selectionSpan);
    }else{
        text.appendChild(selectionSpan);
        charInfosForSelection.push(createCharInfos(selectionSpan, "s", selectionPos));
    }

    // 選択文字列より後の文字列
    for(let i = 0; i < afterSelectionChars.length; i++){
        const char = afterSelectionChars[i];
        const span = createSpan(char);
        text.appendChild(span);

        charInfosForSelection.push(createCharInfos(span, "a", i));
    }

    text.innerHTML = "";

    const beforeSelection = createSpan(beforeSelectionChars.join(""));
    const afterSelection = createSpan(afterSelectionChars.join(""));
    const spanBuf1 = document.createElement("span");
    const spanBuf2 = document.createElement("span");

    text.appendChild(beforeSelection);
    text.appendChild(selectionSpan);
    text.appendChild(afterSelection);
    text.appendChild(spanBuf1);
    text.appendChild(spanBuf2);
    
    selectionSpan.addEventListener("mouseenter", mouseenterSelectedMock);
    selectionSpan.addEventListener("mouseleave", mouseleaveSelectedMock);
    
    hiddenInput.value = selectionSpan.textContent;
    selectInputText(hiddenInput);

    if(selectionCount.right > 0) {
        caretBeforeChars = beforeSelectionChars.concat(selectionSpan.textContent.split(""));
        caretAfterChars = afterSelectionChars;
    }else{
        caretBeforeChars = beforeSelectionChars;
        caretAfterChars = selectionSpan.textContent.split("").concat(afterSelectionChars);
    }

    if(selectionCount.right > 0){
        const afterSelectionChar = charInfosForSelection.find(x => x.pos === "a");
        if(afterSelectionChar) positionCursor(undefined, undefined, {
            left  : afterSelectionChar.left,
            top   : afterSelectionChar.top,
            height: afterSelectionChar.bottom - afterSelectionChar.top
        });
        else positionCursor(undefined, "right", {
            left  : window.scrollX + lastSelectionChar.right,
            top   : window.scrollY + lastSelectionChar.top,
            height: lastSelectionChar.bottom - lastSelectionChar.top
        });
    }else{
        positionCursor(undefined, undefined, {
            left  :charInfosForSelection[selectionPos].left,
            top   :charInfosForSelection[selectionPos].top,
            height:charInfosForSelection[selectionPos].bottom - charInfosForSelection[selectionPos].top
        });
    }
}

function updateChars(){
    caretBeforeChars = content.slice(0, caretBeforeIdx + 1).split("");
    caretAfterChars = content.slice(caretAfterIdx).split("");
}

function createSpan(char, className = ""){
    const span = document.createElement("span");
    span.textContent = char;
    if(className) span.className = className;
    return span;
}

function updateCharRects(){
    allCharRects = Array.from(text.querySelectorAll("span")).map((x, i) => {
        const rect = x.getBoundingClientRect();
        return {
            index : i,
            char  : x.textContent,
            left  : rect.left,
            bottom: rect.bottom
        }    
    });
    window.allCharRects = allCharRects;
}

function render() {
    text.innerHTML = "";
    caretBeforeIdx = -1;
    let caretAfterSpan = null;

    const flag = document.createDocumentFragment();

    // テキストカーソルより前の文字
    for(let i = 0; i < caretBeforeChars.length; i++){
        const span = createSpan(caretBeforeChars[i]);

        if(i == caretBeforeChars.length - 1 && !composingChars.length){
            if(isBackSpace || isInputInSelection){
                if(isComposingEnd || isSelected){
                    caretBeforeIdx = caretBeforeChars.length - 1;
                }else{
                    caretBeforeIdx = caretBeforeChars.length - 2;
                    continue;
                }
            }else{
                caretBeforeIdx = caretBeforeChars.length - 1;
            }
        }
        flag.appendChild(span);
    }

    // 変換中の文字列
    for(let i = 0; i < composingChars.length; i++){
        const span = createSpan(composingChars[i], "unconfirmed");
        if(i == composingChars.length - 1){
            caretBeforeIdx = caretBeforeChars.length - 1;
        }
        flag.appendChild(span);
    }

    // テキストカーソルの後の文字列
    for(let i = 0; i < caretAfterChars.length; i++){
        const span = createSpan(caretAfterChars[i]);
        if(i == 0){
            if (composingChars.length) {
                caretAfterIdx = caretBeforeChars.length + composingChars.length;
            } else {
                caretAfterIdx = caretBeforeChars.length;
                if (isBackSpace && (!isComposingEnd && !isSelected)) {
                    caretAfterIdx -= 1;
                }
            }
            if(isDelete && !isSelected) continue;
            caretAfterSpan = span;
        }

        if(i == 1 && (isDelete && !isSelected)) caretAfterSpan = span;
        if(isSelected && selectionCount.left){
            if(!isBackSpace && !isDelete && !isInputInSelection){
                if(i < selectionCount.left) continue;
                if(i === selectionCount.left) caretAfterSpan = span;
            }
            if(i > selectionCount.left) {
                isSelected = false;
                selectionCount.left = 0;
                isSelectionWithKeyboard = false;
            }
        }

        if(isSelected && selectionCount.right){
            if(!isBackSpace && !isDelete && !isInputInSelection){
                if(i < selectionCount.right) continue;
                if(i === selectionCount.right) caretAfterSpan = span;
            }
            if(i > selectionCount.right) {
                isSelected = false;
                selectionCount.right = 0;
                isSelectionWithKeyboard = false;
            }
        }
        flag.appendChild(span); 
    }
    
    console.log(caretBeforeIdx)
    console.log(caretAfterIdx)
    
    if((isBackSpace || isDelete) && !isComposing) initInput();

    text.innerHTML = "";
    text.appendChild(flag);

    updateCharRects();
    updateContent();
    updateChars();

    isBackSpace = false;
    isDelete = false;
    isComposingEnd = false;
    isInputInSelection = false;

    if(caretAfterSpan){
        positionCursor(caretAfterSpan);
    }else{
        caretAfterSpan = text.querySelector("span:last-child");
        positionCursor(caretAfterSpan, "after");
    }
    
    console.log(isSelected);
    console.log(selectionCount);
    console.log(caretAfterIdx);
    console.log(caretBeforeChars);
    console.log(caretAfterChars);
}

function positionCursor(target = null, where = "before", pos = null) {
    if(target && !pos){
        const rect = target.getBoundingClientRect();
    
        if (where === "before") {
            cursor.style.left = (window.scrollX + rect.left) + "px";
            isLastCursor = false;
        } else if (where === "after") {
            cursor.style.left = (window.scrollX + rect.right) + "px";
            isLastCursor = true;
        }
        cursor.style.top = (window.scrollY + rect.top) + "px";
        cursor.style.height = rect.height + "px";
    }else{
        cursor.style.left = pos.left + "px";
        cursor.style.top = pos.top + "px";
        cursor.style.height = pos.height + "px";

        if(where === "before") isLastCursor = false;
        else isLastCursor = true;
    }
    
    cursor.style.display = "block";
}
</script>
</body>
</html>